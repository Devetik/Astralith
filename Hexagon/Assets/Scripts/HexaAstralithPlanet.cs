using UnityEngine;
using System.Collections.Generic;

namespace HexasphereProcedural {

    /// <summary>
    /// G√©n√©rateur de plan√®te hexagonal complet avec toutes les fonctionnalit√©s
    /// </summary>
    public class HexaAstralithPlanet : MonoBehaviour {
        
        [Header("üåç Configuration de Base")]
        [SerializeField] public int divisions = 3;
        [SerializeField] public float radius = 1f;
        [SerializeField] public float noiseScale = 1f;
        [SerializeField] public float heightAmplitude = 0.2f;
        [SerializeField] public bool showDebugInfo = true;
        
        [Header("üè∑Ô∏è Tag de l'Objet")]
        [SerializeField] public string objectTag = "Planet";
        
        [Header("üé® Mat√©riaux (Assignez dans l'inspector)")]
        [SerializeField] public Material waterMaterial;
        [SerializeField] public Material landMaterial;
        [SerializeField] public Material mountainMaterial;
        
        [Header("üåä Niveaux de Terrain")]
        [SerializeField] public float waterLevel = 0.0f;
        [SerializeField] public float mountainLevel = 0.3f;
        
        [Header("üåä Contr√¥le des Hauteurs")]
        [SerializeField] public bool useHeightControl = true;
        [SerializeField] public float minHeight = -0.3f;
        [SerializeField] public float maxHeight = 0.4f;
        
        [Header("üéµ Bruit Avanc√©")]
        [SerializeField] public bool useAdvancedNoise = true;
        [SerializeField] public float baseNoiseScale = 1f;
        [SerializeField] public int baseOctaves = 4;
        [SerializeField] public float basePersistence = 0.5f;
        [SerializeField] public float baseLacunarity = 2f;
        [SerializeField] public float detailNoiseScale = 2f;
        [SerializeField] public int detailOctaves = 3;
        [SerializeField] public float detailPersistence = 0.3f;
        [SerializeField] public float detailLacunarity = 2f;
        [SerializeField] public bool useRidgeNoise = true;
        [SerializeField] public float ridgeNoiseScale = 0.5f;
        [SerializeField] public float ridgeIntensity = 0.3f;
        
        [Header("üåä Oc√©ans Plats")]
        [SerializeField] public bool useFlatOceans = true;  
        [SerializeField] public bool forceOceanLevel = true;
        
        [Header("üéØ Syst√®me LOD")]
        [SerializeField] public bool enableLOD = true;
        [SerializeField] public Transform cameraTransform;
        [SerializeField] public float lodUpdateInterval = 0.1f;
        [SerializeField] public float lod0Distance = 10f;
        [SerializeField] public float lod1Distance = 25f;
        [SerializeField] public float lod2Distance = 50f;
        [SerializeField] public float lod3Distance = 100f;
        [SerializeField] public float cullDistance = 200f;
        [SerializeField] public int lod0Divisions = 4;
        [SerializeField] public int lod1Divisions = 3;
        [SerializeField] public int lod2Divisions = 2;
        [SerializeField] public int lod3Divisions = 1;
        
        [Header("üåä LOD Fronti√®res")]
        [SerializeField] public bool enableBoundaryLOD = true;
        [SerializeField] public float boundaryDetectionRadius = 2f;
        [SerializeField] public int boundarySubdivisionLevel = 2;
        [SerializeField] public bool detectWaterLandBoundaries = true;
        [SerializeField] public bool detectMountainBoundaries = true;
        
        [Header("üé® LOD Transitions")]
        [SerializeField] public bool enableTransitionSmoothing = true;
        [SerializeField] public float transitionWidth = 1f;
        [SerializeField] public int transitionSubdivisions = 3;
        [SerializeField] public bool smoothWaterLandTransitions = true;
        [SerializeField] public bool smoothMountainTransitions = true;
        
        [Header("üåä LOD Oc√©ans")]
        [SerializeField] public bool preserveOceanStructure = true;
        [SerializeField] public float oceanStructureStrength = 0.5f;
        
        [Header("üåä Syst√®me Oc√©ans Avanc√©")]
        [SerializeField] public bool useAdvancedOceanSystem = true;
        [SerializeField] public bool preserveBaseShape = true;
        [SerializeField] public float oceanFlatteningStrength = 1f;
        
        private MeshRenderer meshRenderer;
        private MeshFilter meshFilter;
        
        // Variables LOD
        private int currentLOD = 0;
        private float lastLODUpdate = 0f;
        private float currentDistance = 0f;
        private Dictionary<int, Mesh> lodMeshes = new Dictionary<int, Mesh>();
        private Dictionary<int, Material[]> lodMaterials = new Dictionary<int, Material[]>();
        
        void Start() {
            // Appliquer le tag √† l'objet
            ApplyTagToObject();
            
            // G√©n√©rer la plan√®te
            GeneratePlanet();
        }
        
        void Update() {
            if (Input.GetKeyDown(KeyCode.R)) {
                GeneratePlanet();
            }
            if (Input.GetKeyDown(KeyCode.H)) {
                ToggleHeightControl();
            }
            
            // Mise √† jour du syst√®me LOD
            if (enableLOD && Time.time - lastLODUpdate > lodUpdateInterval) {
                UpdateLOD();
                lastLODUpdate = Time.time;
            }
        }
        
        public void GeneratePlanet() {
            CreateMesh();
        }
        
        void ApplyTagToObject() {
            if (string.IsNullOrEmpty(objectTag)) {
                Debug.LogWarning("‚ö†Ô∏è Aucun tag d√©fini pour l'objet");
                return;
            }
            
            // V√©rifier si le tag existe
            if (!IsTagValid(objectTag)) {
                Debug.LogWarning($"‚ö†Ô∏è Le tag '{objectTag}' n'existe pas. Cr√©ez-le dans Edit > Project Settings > Tags and Layers");
                return;
            }
            
            // Appliquer le tag
            gameObject.tag = objectTag;
        }
        
        bool IsTagValid(string tag) {
            // V√©rifier si le tag existe dans les tags Unity
            try {
                // Essayer de trouver des objets avec ce tag
                GameObject[] objects = GameObject.FindGameObjectsWithTag(tag);
                return true; // Si on arrive ici, le tag existe
            } catch (UnityException) {
                return false; // Le tag n'existe pas
            }
        }
        
        void CreateMesh() {
            if (meshFilter == null) {
                meshFilter = GetComponent<MeshFilter>();
                if (meshFilter == null) {
                    meshFilter = gameObject.AddComponent<MeshFilter>();
                }
            }
            
            if (meshRenderer == null) {
                meshRenderer = GetComponent<MeshRenderer>();
                if (meshRenderer == null) {
                    meshRenderer = gameObject.AddComponent<MeshRenderer>();
                }
            }
            
            // G√©n√©rer les vertices et triangles
            List<Vector3> vertices = new List<Vector3>();
            List<Vector2> uvs = new List<Vector2>();
            List<int> triangles = new List<int>();
            
            // Cr√©er une sph√®re avec triangulation coh√©rente
            CreateSphereMesh(vertices, uvs, triangles);
            
            // Cr√©er le mesh avec multi-mat√©riaux
            CreateMultiMaterialMesh(vertices, uvs, triangles);
        }
        
        void CreateSphereMesh(List<Vector3> vertices, List<Vector2> uvs, List<int> triangles) {
            // Cr√©er un icosa√®dre de base
            List<Vector3> baseVertices = CreateIcosahedronVertices();
            List<int> baseTriangles = CreateIcosahedronTriangles();
            
            // Subdiviser
            for (int division = 0; division < divisions; division++) {
                SubdivideSphere(baseVertices, baseTriangles);
            }
            
            // Appliquer les hauteurs et cr√©er le mesh final
            for (int i = 0; i < baseVertices.Count; i++) {
                Vector3 vertex = baseVertices[i];
                float height = GenerateHeight(vertex);
                
                // Nouveau syst√®me d'oc√©ans qui pr√©serve la forme de base
                if (useAdvancedOceanSystem && preserveBaseShape) {
                    height = ApplyAdvancedOceanSystem(vertex, height);
                } else {
                    // Ancien syst√®me (pour compatibilit√©)
                    if (useFlatOceans && height <= waterLevel) {
                        height = 0f; // Oc√©ans parfaitement plats
                    } else if (height > waterLevel) {
                        // Pour les terres, ajuster la hauteur
                        if (forceOceanLevel) {
                            height = height - waterLevel; // Ajuster pour que les terres partent du niveau de la mer
                        }
                    }
                }
                
                Vector3 finalVertex = vertex * (radius + height);
                
                vertices.Add(finalVertex);
                uvs.Add(new Vector2(vertex.x, vertex.y));
            }
            
            // Copier les triangles
            triangles.AddRange(baseTriangles);
        }
        
        float GenerateHeight(Vector3 position) {
            if (useAdvancedNoise) {
                return GenerateAdvancedHeight(position);
            } else {
                return GeneratePerlinHeight(position);
            }
        }
        
        float GeneratePerlinHeight(Vector3 position) {
            // Utiliser les coordonn√©es sph√©riques pour un bruit plus naturel
            float latitude = Mathf.Asin(position.y);
            float longitude = Mathf.Atan2(position.z, position.x);
            
            // Convertir en coordonn√©es UV pour le bruit
            float u = (longitude + Mathf.PI) / (2f * Mathf.PI);
            float v = (latitude + Mathf.PI / 2f) / Mathf.PI;
            
            // G√©n√©rer plusieurs octaves de bruit
            float height = 0f;
            float frequency = 1f;
            float amplitude = heightAmplitude;
            float maxValue = 0f;

            for (int i = 0; i < 6; i++) {
                float noiseValue = Mathf.PerlinNoise(
                    u * noiseScale * frequency,
                    v * noiseScale * frequency
                );
                height += noiseValue * amplitude;
                maxValue += amplitude;
                frequency *= 2f;
                amplitude *= 0.5f;
            }

            // Normaliser le r√©sultat
            if (maxValue > 0) {
                height = height / maxValue;
            }

            return height;
        }
        
        float GenerateAdvancedHeight(Vector3 position) {
            // Coordonn√©es sph√©riques
            float latitude = Mathf.Asin(position.y);
            float longitude = Mathf.Atan2(position.z, position.x);
            
            // Convertir en coordonn√©es UV
            float u = (longitude + Mathf.PI) / (2f * Mathf.PI);
            float v = (latitude + Mathf.PI / 2f) / Mathf.PI;
            
            // Bruit de base (grandes structures)
            float baseHeight = GenerateFractalNoise(u, v, baseNoiseScale, baseOctaves, basePersistence, baseLacunarity);
            
            // Bruit de d√©tail (petites structures)
            float detailHeight = GenerateFractalNoise(u, v, detailNoiseScale, detailOctaves, detailPersistence, detailLacunarity);
            
            // Bruit de ridges (montagnes)
            float ridgeHeight = 0f;
            if (useRidgeNoise) {
                ridgeHeight = GenerateRidgeNoise(u, v, ridgeNoiseScale) * ridgeIntensity;
            }
            
            // Combiner les bruits
            float totalHeight = (baseHeight + detailHeight * 0.3f + ridgeHeight) * heightAmplitude;
            
            return totalHeight;
        }
        
        float GenerateFractalNoise(float u, float v, float scale, int octaves, float persistence, float lacunarity) {
            float height = 0f;
            float frequency = 1f;
            float amplitude = 1f;
            float maxValue = 0f;
            
            for (int i = 0; i < octaves; i++) {
                float noiseValue = Mathf.PerlinNoise(u * scale * frequency, v * scale * frequency);
                height += noiseValue * amplitude;
                maxValue += amplitude;
                frequency *= lacunarity;
                amplitude *= persistence;
            }
            
            if (maxValue > 0) {
                height = height / maxValue;
            }
            
            return height;
        }
        
        float GenerateRidgeNoise(float u, float v, float scale) {
            float noise1 = Mathf.PerlinNoise(u * scale, v * scale);
            float noise2 = Mathf.PerlinNoise(u * scale * 2f, v * scale * 2f);
            
            // Cr√©er des ridges en utilisant la valeur absolue
            float ridge = Mathf.Abs(noise1 - 0.5f) * 2f;
            ridge = 1f - ridge;
            ridge = ridge * ridge;
            
            return ridge;
        }
        
        void CreateMultiMaterialMesh(List<Vector3> vertices, List<Vector2> uvs, List<int> triangles) {
            // S√©parer les triangles par type de terrain
            List<int> waterTriangles = new List<int>();
            List<int> landTriangles = new List<int>();
            List<int> mountainTriangles = new List<int>();
            
            for (int i = 0; i < triangles.Count; i += 3) {
                int p1 = triangles[i];
                int p2 = triangles[i + 1];
                int p3 = triangles[i + 2];
                
                // Calculer l'altitude moyenne du triangle
                float avgHeight = (GetVertexHeight(vertices[p1]) + GetVertexHeight(vertices[p2]) + GetVertexHeight(vertices[p3])) / 3f;
                
                // Assigner au bon type de terrain
                if (avgHeight < waterLevel) {
                    waterTriangles.Add(p1);
                    waterTriangles.Add(p2);
                    waterTriangles.Add(p3);
                } else if (avgHeight < mountainLevel) {
                    landTriangles.Add(p1);
                    landTriangles.Add(p2);
                    landTriangles.Add(p3);
                } else {
                    mountainTriangles.Add(p1);
                    mountainTriangles.Add(p2);
                    mountainTriangles.Add(p3);
                }
            }
            
            // Cr√©er le mesh avec submeshes
            Mesh mesh = new Mesh();
            mesh.name = "HexaAstralithPlanet";
            mesh.vertices = vertices.ToArray();
            mesh.uv = uvs.ToArray();
            
            // Cr√©er les submeshes
            mesh.subMeshCount = 3;
            mesh.SetTriangles(waterTriangles.ToArray(), 0);
            mesh.SetTriangles(landTriangles.ToArray(), 1);
            mesh.SetTriangles(mountainTriangles.ToArray(), 2);
            
            mesh.RecalculateNormals();
            mesh.RecalculateBounds();
            
            meshFilter.mesh = mesh;
            
            // Appliquer les mat√©riaux
            ApplyMultiMaterials();
            
            Debug.Log($"üé® Plan√®te cr√©√©e: {waterTriangles.Count/3} triangles eau, {landTriangles.Count/3} triangles terre, {mountainTriangles.Count/3} triangles montagne");
        }
        
        float GetVertexHeight(Vector3 vertex) {
            Vector3 normalizedVertex = vertex.normalized;
            return GenerateHeight(normalizedVertex);
        }
        
        void ApplyMultiMaterials() {
            if (meshRenderer == null) return;
            
            // Cr√©er des mat√©riaux par d√©faut si aucun n'est assign√©
            if (waterMaterial == null) {
                waterMaterial = CreateDefaultMaterial(Color.blue, "Water");
            }
            if (landMaterial == null) {
                landMaterial = CreateDefaultMaterial(Color.green, "Land");
            }
            if (mountainMaterial == null) {
                mountainMaterial = CreateDefaultMaterial(Color.gray, "Mountain");
            }
            
            // Assigner les mat√©riaux
            Material[] materials = { waterMaterial, landMaterial, mountainMaterial };
            meshRenderer.materials = materials;
            
            Debug.Log("üé® Mat√©riaux de la plan√®te appliqu√©s !");
        }
        
        // M√©thodes de g√©n√©ration de sph√®re
        List<Vector3> CreateIcosahedronVertices() {
            List<Vector3> vertices = new List<Vector3>();
            float t = (1f + Mathf.Sqrt(5f)) / 2f;
            
            Vector3[] icosahedronVertices = {
                new Vector3(-1, t, 0), new Vector3(1, t, 0), new Vector3(-1, -t, 0), new Vector3(1, -t, 0),
                new Vector3(0, -1, t), new Vector3(0, 1, t), new Vector3(0, -1, -t), new Vector3(0, 1, -t),
                new Vector3(t, 0, -1), new Vector3(t, 0, 1), new Vector3(-t, 0, -1), new Vector3(-t, 0, 1)
            };
            
            foreach (Vector3 vertex in icosahedronVertices) {
                vertices.Add(vertex.normalized);
            }
            
            return vertices;
        }
        
        List<int> CreateIcosahedronTriangles() {
            List<int> triangles = new List<int>();
            
            int[][] icosahedronFaces = {
                new int[] {0, 11, 5}, new int[] {0, 5, 1}, new int[] {0, 1, 7}, new int[] {0, 7, 10}, new int[] {0, 10, 11},
                new int[] {1, 5, 9}, new int[] {5, 11, 4}, new int[] {11, 10, 2}, new int[] {10, 7, 6}, new int[] {7, 1, 8},
                new int[] {3, 9, 4}, new int[] {3, 4, 2}, new int[] {3, 2, 6}, new int[] {3, 6, 8}, new int[] {3, 8, 9},
                new int[] {4, 9, 5}, new int[] {2, 4, 11}, new int[] {6, 2, 10}, new int[] {8, 6, 7}, new int[] {9, 8, 1}
            };
            
            foreach (int[] face in icosahedronFaces) {
                triangles.Add(face[0]);
                triangles.Add(face[1]);
                triangles.Add(face[2]);
            }
            
            return triangles;
        }
        
        void SubdivideSphere(List<Vector3> vertices, List<int> triangles) {
            List<int> newTriangles = new List<int>();
            Dictionary<string, int> edgePoints = new Dictionary<string, int>();
            
            for (int i = 0; i < triangles.Count; i += 3) {
                int p1 = triangles[i];
                int p2 = triangles[i + 1];
                int p3 = triangles[i + 2];
                
                // Cr√©er les points du milieu des ar√™tes
                int mid1 = GetOrCreateMidPoint(p1, p2, vertices, edgePoints);
                int mid2 = GetOrCreateMidPoint(p2, p3, vertices, edgePoints);
                int mid3 = GetOrCreateMidPoint(p3, p1, vertices, edgePoints);
                
                // Cr√©er 4 nouveaux triangles
                newTriangles.Add(p1); newTriangles.Add(mid1); newTriangles.Add(mid3);
                newTriangles.Add(mid1); newTriangles.Add(p2); newTriangles.Add(mid2);
                newTriangles.Add(mid3); newTriangles.Add(mid2); newTriangles.Add(p3);
                newTriangles.Add(mid1); newTriangles.Add(mid2); newTriangles.Add(mid3);
            }
            
            triangles.Clear();
            triangles.AddRange(newTriangles);
        }
        
        int GetOrCreateMidPoint(int p1, int p2, List<Vector3> vertices, Dictionary<string, int> edgePoints) {
            string key1 = $"{p1}-{p2}";
            string key2 = $"{p2}-{p1}";
            
            if (edgePoints.ContainsKey(key1)) return edgePoints[key1];
            if (edgePoints.ContainsKey(key2)) return edgePoints[key2];
            
            Vector3 midPoint = (vertices[p1] + vertices[p2]) / 2f;
            midPoint = midPoint.normalized;
            
            vertices.Add(midPoint);
            int newIndex = vertices.Count - 1;
            edgePoints[key1] = newIndex;
            
            return newIndex;
        }
        
        Material CreateDefaultMaterial(Color color, string name) {
            Material mat = new Material(Shader.Find("Standard"));
            mat.name = name;
            mat.color = color;
            mat.SetFloat("_Metallic", 0f);
            mat.SetFloat("_Smoothness", 0.5f);
            return mat;
        }
        
        // M√©thodes utilitaires
        public void ToggleHeightControl() {
            useHeightControl = !useHeightControl;
            if (useHeightControl) {
                CalculateLevelsFromHeights();
            }
            Debug.Log($"Contr√¥le de hauteur: {(useHeightControl ? "ON" : "OFF")}");
        }
        
        public void SetObjectTag(string newTag) {
            if (string.IsNullOrEmpty(newTag)) {
                Debug.LogWarning("‚ö†Ô∏è Tag vide fourni");
                return;
            }
            
            objectTag = newTag;
            ApplyTagToObject();
        }
        
        public void ApplyTagNow() {
            ApplyTagToObject();
        }
        
        void CalculateLevelsFromHeights() {
            if (!useHeightControl) return;
            
            float range = maxHeight - minHeight;
            waterLevel = minHeight + (range * 0.3f);
            mountainLevel = minHeight + (range * 0.7f);
            
            Debug.Log($"üìä Niveaux calcul√©s: Min={minHeight:F2}, Max={maxHeight:F2}, Eau={waterLevel:F2}, Montagne={mountainLevel:F2}");
        }
        
        void OnGUI() {
            GUILayout.BeginArea(new Rect(10, 10, 400, 350));
            GUILayout.BeginVertical("box");
            
            GUILayout.Label("üåç HexaAstralith Planet", GUI.skin.box);
            GUILayout.Space(10);
            
            if (GUILayout.Button("G√©n√©rer Plan√®te")) {
                GeneratePlanet();
            }
            
            GUILayout.Space(10);
            
            GUILayout.Label("Contr√¥les:");
            GUILayout.Label("R : R√©g√©n√©rer");
            GUILayout.Label("H : Toggle contr√¥le hauteur");
            
            GUILayout.Space(10);
            
            GUILayout.Label("Fonctionnalit√©s:");
            GUILayout.Label("‚úÖ Bruit sph√©rique");
            GUILayout.Label("‚úÖ Multi-mat√©riaux");
            GUILayout.Label("‚úÖ Oc√©ans plats");
            GUILayout.Label("‚úÖ Bruit avanc√©");
            GUILayout.Label("‚úÖ Contr√¥le hauteurs");
            GUILayout.Label("‚úÖ Ridges et d√©tails");
            
            GUILayout.Space(10);
            
            GUILayout.Label("Statut:");
            GUILayout.Label($"Bruit avanc√©: {(useAdvancedNoise ? "ON" : "OFF")}");
            GUILayout.Label($"Oc√©ans plats: {(useFlatOceans ? "ON" : "OFF")}");
            GUILayout.Label($"Contr√¥le hauteur: {(useHeightControl ? "ON" : "OFF")}");
            GUILayout.Label($"Ridges: {(useRidgeNoise ? "ON" : "OFF")}");
            
            GUILayout.Space(5);
            
            GUILayout.Label("LOD:");
            GUILayout.Label($"LOD actuel: {currentLOD}");
            GUILayout.Label($"Distance: {currentDistance:F1}");
            GUILayout.Label($"LOD activ√©: {(enableLOD ? "ON" : "OFF")}");
            GUILayout.Label($"Fronti√®res: {(enableBoundaryLOD ? "ON" : "OFF")}");
            GUILayout.Label($"Transitions: {(enableTransitionSmoothing ? "ON" : "OFF")}");
            GUILayout.Label($"Oc√©ans pr√©serv√©s: {(preserveOceanStructure ? "ON" : "OFF")}");
            
            GUILayout.Space(5);
            
            GUILayout.Label("Oc√©ans avanc√©s:");
            GUILayout.Label($"Syst√®me avanc√©: {(useAdvancedOceanSystem ? "ON" : "OFF")}");
            GUILayout.Label($"Forme pr√©serv√©e: {(preserveBaseShape ? "ON" : "OFF")}");
            GUILayout.Label($"Force aplatissement: {oceanFlatteningStrength:F2}");
            
            GUILayout.Space(10);
            
            GUILayout.Label("Mat√©riaux:");
            GUILayout.Label($"Eau: {(waterMaterial != null ? "‚úÖ" : "‚ùå")}");
            GUILayout.Label($"Terre: {(landMaterial != null ? "‚úÖ" : "‚ùå")}");
            GUILayout.Label($"Montagne: {(mountainMaterial != null ? "‚úÖ" : "‚ùå")}");
            
            GUILayout.Space(10);
            
            GUILayout.Label("Tag:");
            GUILayout.Label($"Tag actuel: {objectTag}");
            GUILayout.Label($"Tag appliqu√©: {gameObject.tag}");
            
            GUILayout.Space(5);
            
            if (GUILayout.Button("üè∑Ô∏è Appliquer Tag Maintenant")) {
                ApplyTagNow();
            }
            
            GUILayout.Space(5);
            
            if (GUILayout.Button("üéØ Forcer LOD 0")) {
                SetLODLevel(0);
            }
            if (GUILayout.Button("üéØ Forcer LOD 1")) {
                SetLODLevel(1);
            }
            if (GUILayout.Button("üéØ Forcer LOD 2")) {
                SetLODLevel(2);
            }
            if (GUILayout.Button("üéØ Forcer LOD 3")) {
                SetLODLevel(3);
            }
            if (GUILayout.Button("üîÑ Mise √† jour LOD")) {
                ForceLODUpdate();
            }
            
            GUILayout.Space(5);
            
            if (GUILayout.Button("üåä Toggle Syst√®me Oc√©ans Avanc√©")) {
                useAdvancedOceanSystem = !useAdvancedOceanSystem;
                GeneratePlanet(); // R√©g√©n√©rer avec le nouveau syst√®me
            }
            
            if (GUILayout.Button("üîß Toggle Pr√©servation Forme")) {
                preserveBaseShape = !preserveBaseShape;
                GeneratePlanet(); // R√©g√©n√©rer avec le nouveau syst√®me
            }
            
            GUILayout.EndVertical();
            GUILayout.EndArea();
        }
        
        // === SYST√àME LOD ===
        
        void UpdateLOD() {
            if (cameraTransform == null) {
                Camera mainCamera = Camera.main;
                if (mainCamera != null) {
                    cameraTransform = mainCamera.transform;
                } else {
                    return;
                }
            }
            
            // Calculer la distance √† la cam√©ra
            currentDistance = Vector3.Distance(transform.position, cameraTransform.position);
            
            // D√©terminer le niveau LOD appropri√©
            int newLOD = DetermineLODLevel(currentDistance);
            
            // Appliquer le nouveau niveau LOD si n√©cessaire
            if (newLOD != currentLOD) {
                ApplyLODLevel(newLOD);
            }
            
            // Culling si trop loin
            if (currentDistance > cullDistance) {
                SetVisibility(false);
            } else {
                SetVisibility(true);
            }
        }
        
        int DetermineLODLevel(float distance) {
            if (distance <= lod0Distance) return 0;
            if (distance <= lod1Distance) return 1;
            if (distance <= lod2Distance) return 2;
            if (distance <= lod3Distance) return 3;
            return 3; // LOD le plus bas par d√©faut
        }
        
        void ApplyLODLevel(int lodLevel) {
            currentLOD = lodLevel;
            
            // G√©n√©rer le mesh LOD si pas encore en cache
            if (!lodMeshes.ContainsKey(lodLevel)) {
                GenerateLODMesh(lodLevel);
            }
            
            // Appliquer le mesh LOD
            if (meshFilter != null && lodMeshes.ContainsKey(lodLevel)) {
                meshFilter.mesh = lodMeshes[lodLevel];
            }
            
            // Appliquer les mat√©riaux LOD
            if (meshRenderer != null && lodMaterials.ContainsKey(lodLevel)) {
                meshRenderer.materials = lodMaterials[lodLevel];
            }
            
            if (showDebugInfo) {
                Debug.Log($"üéØ LOD chang√© vers niveau {lodLevel} (distance: {currentDistance:F1})");
            }
        }
        
        void GenerateLODMesh(int lodLevel) {
            // Cr√©er un mesh temporaire pour ce niveau LOD
            Mesh tempMesh = new Mesh();
            tempMesh.name = $"HexaLOD_{lodLevel}";
            
            // G√©n√©rer les vertices et triangles pour ce niveau LOD
            List<Vector3> vertices = new List<Vector3>();
            List<Vector2> uvs = new List<Vector2>();
            List<int> triangles = new List<int>();
            
            // Utiliser la m√©thode de g√©n√©ration existante avec moins de divisions
            CreateLODSphereMesh(vertices, uvs, triangles, lodLevel);
            
            // Cr√©er le mesh final
            tempMesh.vertices = vertices.ToArray();
            tempMesh.uv = uvs.ToArray();
            tempMesh.triangles = triangles.ToArray();
            tempMesh.RecalculateNormals();
            tempMesh.RecalculateBounds();
            
            lodMeshes[lodLevel] = tempMesh;
            
            // Cr√©er les mat√©riaux pour ce niveau LOD
            Material[] materials = CreateMaterialsForLOD(lodLevel);
            lodMaterials[lodLevel] = materials;
        }
        
        void CreateLODSphereMesh(List<Vector3> vertices, List<Vector2> uvs, List<int> triangles, int lodLevel) {
            // Cr√©er un icosa√®dre de base
            List<Vector3> baseVertices = CreateIcosahedronVertices();
            List<int> baseTriangles = CreateIcosahedronTriangles();
            
            // Subdiviser selon le niveau LOD
            int divisions = GetDivisionsForLOD(lodLevel);
            for (int division = 0; division < divisions; division++) {
                SubdivideSphere(baseVertices, baseTriangles);
            }
            
            // Appliquer les hauteurs et cr√©er le mesh final
            for (int i = 0; i < baseVertices.Count; i++) {
                Vector3 vertex = baseVertices[i];
                float height = GenerateHeightForLOD(vertex, lodLevel);
                
                Vector3 finalVertex = vertex * (radius + height);
                vertices.Add(finalVertex);
                uvs.Add(new Vector2(vertex.x, vertex.y));
            }
            
            // Copier les triangles
            triangles.AddRange(baseTriangles);
        }
        
        float GenerateHeightForLOD(Vector3 position, int lodLevel) {
            // R√©duire la complexit√© du bruit selon le niveau LOD
            float noiseScaleLOD = noiseScale;
            float heightAmplitudeLOD = heightAmplitude;
            
            // R√©duire seulement la complexit√© du bruit, pas l'amplitude globale
            if (lodLevel >= 2) {
                noiseScaleLOD *= 0.5f;
                // Pr√©server l'amplitude pour maintenir les oc√©ans
            }
            if (lodLevel >= 3) {
                noiseScaleLOD *= 0.3f;
                // Pr√©server l'amplitude pour maintenir les oc√©ans
            }
            
            // G√©n√©rer le bruit avec la complexit√© r√©duite mais amplitude pr√©serv√©e
            float height = GeneratePerlinHeightLOD(position, noiseScaleLOD, heightAmplitudeLOD, lodLevel);
            
            // Appliquer le syst√®me d'oc√©ans avanc√© pour le LOD aussi
            if (useAdvancedOceanSystem && preserveBaseShape) {
                height = ApplyAdvancedOceanSystem(position, height);
            } else {
                // Ancien syst√®me (pour compatibilit√©)
                if (useFlatOceans && height <= waterLevel) {
                    height = 0f; // Oc√©ans parfaitement plats
                } else if (height > waterLevel) {
                    // Pour les terres, ajuster la hauteur
                    if (forceOceanLevel) {
                        height = height - waterLevel; // Ajuster pour que les terres partent du niveau de la mer
                    }
                }
            }
            
            return height;
        }
        
        float GeneratePerlinHeightLOD(Vector3 position, float noiseScaleLOD, float heightAmplitudeLOD, int lodLevel) {
            // Version simplifi√©e du bruit pour les niveaux LOD √©lev√©s
            float latitude = Mathf.Asin(position.y);
            float longitude = Mathf.Atan2(position.z, position.x);
            
            float u = (longitude + Mathf.PI) / (2f * Mathf.PI);
            float v = (latitude + Mathf.PI / 2f) / Mathf.PI;
            
            // Moins d'octaves pour les niveaux LOD √©lev√©s, mais garder au moins 2 octaves
            float height = 0f;
            float frequency = 1f;
            float amplitude = heightAmplitudeLOD;
            float maxValue = 0f;
            
            int octaves = Mathf.Max(2, 6 - lodLevel); // R√©duire les octaves mais garder au moins 2
            
            for (int i = 0; i < octaves; i++) {
                float noiseValue = Mathf.PerlinNoise(
                    u * noiseScaleLOD * frequency,
                    v * noiseScaleLOD * frequency
                );
                height += noiseValue * amplitude;
                maxValue += amplitude;
                frequency *= 2f;
                amplitude *= 0.5f;
            }
            
            if (maxValue > 0) {
                height = height / maxValue;
            }
            
            // Pour les niveaux LOD √©lev√©s, ajouter un bruit de base pour maintenir la structure
            if (lodLevel >= 2 && preserveOceanStructure) {
                float baseNoise = Mathf.PerlinNoise(u * noiseScaleLOD * 0.5f, v * noiseScaleLOD * 0.5f);
                height = Mathf.Lerp(height, baseNoise, oceanStructureStrength); // M√©langer avec un bruit de base
            }
            
            return height;
        }
        
        Material[] CreateMaterialsForLOD(int lodLevel) {
            Material[] materials = new Material[3]; // Eau, Terre, Montagne
            
            // Utiliser les mat√©riaux existants pour tous les niveaux LOD
            materials[0] = waterMaterial;
            materials[1] = landMaterial;
            materials[2] = mountainMaterial;
            
            return materials;
        }
        
        int GetDivisionsForLOD(int lodLevel) {
            switch (lodLevel) {
                case 0: return lod0Divisions;
                case 1: return lod1Divisions;
                case 2: return lod2Divisions;
                case 3: return lod3Divisions;
                default: return lod3Divisions;
            }
        }
        
        void SetVisibility(bool visible) {
            if (meshRenderer != null) {
                meshRenderer.enabled = visible;
            }
        }
        
        // M√©thodes publiques LOD
        public void SetLODLevel(int lodLevel) {
            if (lodLevel >= 0 && lodLevel <= 3) {
                ApplyLODLevel(lodLevel);
            }
        }
        
        public int GetCurrentLOD() {
            return currentLOD;
        }
        
        public float GetCurrentDistance() {
            return currentDistance;
        }
        
        public void ForceLODUpdate() {
            UpdateLOD();
        }
        
        // === SYST√àME OC√âANS AVANC√â ===
        
        float ApplyAdvancedOceanSystem(Vector3 vertex, float originalHeight) {
            // Pr√©server la forme de base : ne pas modifier la hauteur globale
            // Seulement aplatir les zones qui devraient √™tre submerg√©es
            
            if (originalHeight <= waterLevel) {
                // Zone qui devrait √™tre submerg√©e
                // Au lieu de mettre √† 0, on aplatit progressivement vers le niveau de l'eau
                float flatteningFactor = Mathf.Clamp01((waterLevel - originalHeight) / waterLevel);
                float flattenedHeight = Mathf.Lerp(originalHeight, waterLevel, flatteningFactor * oceanFlatteningStrength);
                
                // Pour les oc√©ans plats, on peut encore les aplatir compl√®tement si souhait√©
                if (useFlatOceans) {
                    return waterLevel; // Niveau constant pour les oc√©ans
                } else {
                    return flattenedHeight; // Aplatissement progressif
                }
            } else {
                // Zone terrestre : garder la hauteur originale
                // Pas de modification de la forme de base
                return originalHeight;
            }
        }
        
        // M√©thode pour calculer la hauteur de base sans oc√©ans (pour debug)
        public float GetBaseHeight(Vector3 vertex) {
            return GenerateHeight(vertex);
        }
        
        // M√©thode pour calculer la hauteur avec oc√©ans appliqu√©s
        public float GetHeightWithOceans(Vector3 vertex) {
            float baseHeight = GenerateHeight(vertex);
            return ApplyAdvancedOceanSystem(vertex, baseHeight);
        }
    }
}
